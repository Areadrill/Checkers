package logic;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;

import cli.Cli;
/**
 * Class that holds the game's logic
 *
 */
public class Game implements Serializable{
	
	public int currentPlayer;
	public Player[] players;
	public Board board;

	/**
	 * Constructor for this class, where you initialize the necessary variables
	 * @throws ImpossibleException
	 */
	public Game() throws ImpossibleException {
		currentPlayer = 0;
		players = new Player[2];
		board = new Board();
		mainMenu();
	}
	
	/**
	 * Constructor used only for my own testing purposes
	 * @param test
	 */
	public Game(boolean test){
		currentPlayer = 0;
		players = new Player[2];
		board = new Board();
	}

	public static void main(String[] args) throws ImpossibleException {
		Game game = new Game();
	}

	/**
	 * The game's main menu. The program will loop this function until the user chooses to leave the loop
	 * @throws ImpossibleException
	 */
	public void mainMenu() throws ImpossibleException {
		while(true){
			String[] mainMenuOptions = { "New Game", "Exit" };

			switch (Cli.getOption(mainMenuOptions)) {
			case 1:
				startNewGame();
				break;
			case 2:
				System.exit(0);
				break;
			default:
				throw new ImpossibleException();

			}
		}	
	}

	/**
	 * Method called by the main menu in which a new game is started and run until it finishes.
	 */
	public void startNewGame() {
		Player pl1 = new Player(Cli.getLine("Type in the name for player 1"));
		Player pl2 = new Player(Cli.getLine("Type in the name for player 2"));

		players[0] = pl1;
		players[1] = pl2;
		initializeBoard(this.board, pl1,pl2);
		
		boolean gameOver = false;
		
		while(!gameOver){
			gameOver = processTurn();
		}
		this.currentPlayer = 0;
		
		
	}

	/**
	 * Method that takes care of processing a player's turn and verifies if the turn lead to a player's victory
	 * @return true if the game is over, false otherwise
	 */
	private boolean processTurn() {
		processMove();
		this.currentPlayer = ((this.currentPlayer+1) % 2);
		
		int[] pieces = this.board.pieceCount(this.players[0], this.players[1]);
		
		if(pieces[0] == 0){
			System.out.println(this.players[0].getName() + " wins!");
			return true;
		}
		else if(pieces[1] == 0){
			System.out.println(this.players[0].getName() + " wins!");
			return true;
		}else{
			return false;
		}
	}
	/**
	 * Method where input is gathered from the user and compared to the valid moves generated by the program (to check their validity)
	 */
	public void processMove(){
		this.board.printBoard();
		System.out.print("\n\n");
		
		System.out.println("Select the piece you want to move:");
		Piece pieceToMove = this.board.getBoard().get(Cli.getPosition());
		while(pieceToMove == null){
			System.out.println("No piece there! Try again.");
			pieceToMove = this.board.getBoard().get(Cli.getPosition());
		}
		while(!pieceToMove.getPlayer().equals(this.players[this.currentPlayer])){
			System.out.println("Not your piece! Try again.");
			pieceToMove = this.board.getBoard().get(Cli.getPosition());
		}
		
		ArrayList<PositionPair> validPositions;
		
		if(pieceToMove.isKing()){
			validPositions = getAvailableMoves(pieceToMove, Direction.SE, null, false);
			validPositions.addAll(getAvailableMoves(pieceToMove, Direction.SW, null, false));
			validPositions = getAvailableMoves(pieceToMove, Direction.NE, null, false);
			validPositions.addAll(getAvailableMoves(pieceToMove, Direction.NW, null, false));
		}
		else if(this.currentPlayer == 0){
			validPositions = getAvailableMoves(pieceToMove, Direction.SE, null, false);
			validPositions.addAll(getAvailableMoves(pieceToMove, Direction.SW, null, false));
		}
		else{
			validPositions = getAvailableMoves(pieceToMove, Direction.NE, null, false);
			validPositions.addAll(getAvailableMoves(pieceToMove, Direction.NW, null, false));
		}
		
		
		System.out.println("Select where you want to move it to:");
		Position newPos = Cli.getPosition();
		
		while(!validPositions.contains(new PositionPair(null, newPos))){
			System.out.println("Invalid move! Try again.");
			newPos = Cli.getPosition();
		}
		
		Position originalPos = new Position(pieceToMove.getPosition());
		
		this.board.getBoard().remove(pieceToMove.getPosition());
		pieceToMove.getPosition().set(newPos);
		this.board.getBoard().put(pieceToMove.getPosition(), pieceToMove); 
		erasePieces(originalPos, newPos);
		if(this.currentPlayer == 0 && newPos.getY() == 7 || this.currentPlayer == 1 && newPos.getY() == 0){
			pieceToMove.setKing(true);
		}
		
		//this block checks if there is a capture chain available and forces the user to take it
		while(true){
			boolean movesLeft = false;
			for(PositionPair pp: validPositions){
				if(pp.getOrigin() != null && pp.getOrigin().equals(newPos)){
					movesLeft = true;
				}
			}
			if(!movesLeft){
				break;
			}
			else{
				this.board.printBoard();
				System.out.println(this.players[this.currentPlayer].getName() + " still has available moves!");
				System.out.println("Select where you want to move the piece.");
				Position newerPos = Cli.getPosition();
				
				while(!validPositions.contains(new PositionPair(newPos, newerPos))){
					System.out.println("Invalid move! Try again.");
					newerPos = Cli.getPosition();
				}
				
				this.board.getBoard().remove(pieceToMove.getPosition());
				pieceToMove.getPosition().set(newerPos);
				this.board.getBoard().put(pieceToMove.getPosition(), pieceToMove);
				erasePieces(newPos, newerPos);
				if(this.currentPlayer == 0 && newerPos.getY() == 7 || this.currentPlayer == 1 && newerPos.getY() == 0){
					pieceToMove.setKing(true);
				}
				newPos = newerPos;
				
			}
		}
		
	}
	
	public enum Direction{
		NE, NW, SE, SW
	}
	
	/**
	 * Generates all valid moves for a piece according to the provided direction.
	 * @param piece The piece for which to evaluate
	 * @param dir The direction in which to evaluate
	 * @param origin Used for capture chains, the position from which the next capture is made from
	 * @param onlyJumps Used for capture chains. If true, the method will not count the regular movement (non-capture)
	 * @return an ArrayList with all valid movements and their origin (most commonly null)
	 */
	public ArrayList<PositionPair> getAvailableMoves(Piece piece, Direction dir, Position origin, boolean onlyJumps){
		ArrayList<PositionPair> validPositions = new ArrayList<PositionPair>();
		int xIncrement = 0, yIncrement = 0;
		Position currPos = new Position(piece.getPosition());
			
		switch(dir){
			case NE:
				xIncrement = 1;
				yIncrement = -1;
				break;
			case NW:
				xIncrement = -1;
				yIncrement = -1;
				break;
			case SE:
				xIncrement = 1;
				yIncrement = 1;
				break;
			case SW:
				xIncrement = -1;
				yIncrement = 1;
				break;
			default:
				break;
		}
		
		boolean finished = false;
		int distance = 0;
		while(!finished){
			currPos.set(currPos.getX()+xIncrement, currPos.getY()+yIncrement);
			
			if(currPos.getX() < 0 || currPos.getX() > 7 || currPos.getY() < 0 || currPos.getY() > 7){
				break;
			}
			
			if(currPos.getX() == 0 || currPos.getX() == 7 || currPos.getY() == 0 || currPos.getY() == 7){
				finished = true;
			}
			
			Piece p = this.board.getBoard().get(currPos);
			
			if(p == null){
				if(onlyJumps){
					break;
				}
				validPositions.add(new PositionPair(origin, currPos));
				if(++distance > 0 && !piece.isKing()){
					finished = true;
				}
			}
			else if(p.getPlayer().equals(this.players[this.currentPlayer])){
				finished = true;
			}
			else{
				if(!finished){
					Position beyondPos = new Position(currPos.getX()+xIncrement, currPos.getY()+yIncrement);
					
					Piece p2 = this.board.getBoard().get(beyondPos);
					if(p2 == null){
						validPositions.add(new PositionPair(origin, beyondPos));
						if(yIncrement > 0){
							validPositions.addAll(getAvailableMoves(new Piece(this.players[this.currentPlayer], beyondPos), Direction.SE, beyondPos, true));
							validPositions.addAll(getAvailableMoves(new Piece(this.players[this.currentPlayer], beyondPos), Direction.SW, beyondPos, true));
						}
						else{
							validPositions.addAll(getAvailableMoves(new Piece(this.players[this.currentPlayer], beyondPos), Direction.NE, beyondPos, true));
							validPositions.addAll(getAvailableMoves(new Piece(this.players[this.currentPlayer], beyondPos), Direction.NW, beyondPos, true));
						}
					}
				}
				finished = true;
			}
			
		}
		
		
		return validPositions;
	}
	
	/**
	 * Checks if there're pieces belonging to the enemy player in between the two provided points and deletes them.
	 * @param posOrigin Origin of the move that to evaluate
	 * @param posDestination Destination of the move.
	 */
	public void erasePieces(Position posOrigin, Position posDestination){
		int deltaX = posDestination.getX()-posOrigin.getX() , deltaY = posDestination.getY()-posOrigin.getY();
		Position travelPos = new Position(posDestination);
		if(Math.abs(deltaX) > 1){
			while(true){
				travelPos.set(travelPos.getX()-((deltaX > 0)?1:-1), travelPos.getY()-((deltaY > 0)?1:-1));
				
				if(travelPos.equals(posOrigin)){
					break;
				}
				Piece foe = this.board.getBoard().get(travelPos);
				if(foe != null && !foe.getPlayer().equals(this.players[this.currentPlayer])){
					this.board.getBoard().remove(travelPos);
				}
			}
		}
	}

	/**
	 * Places all pieces in their starting positions
	 * @param brd The board
	 * @param pl1 Player 1
	 * @param pl2 Player 2
	 */
	public void initializeBoard(Board brd, Player pl1, Player pl2) {
		brd.getBoard().clear(); //to guarantee a fresh start
		for (int i = 0; i < 8; i++) { //Y
			for (int j = 0; j < 8; j++) { //X
				if(i < 3 || i >= 5){
					if((i % 2 == 0 && j % 2 != 0) || (i % 2 != 0 && j % 2 == 0)){
						brd.getBoard().put(new Position(j, i), new Piece(((i < 3) ? pl1 : pl2), new Position(j, i)));
					}
				}
			}
		}
	}
}
